from PIL import Image, ImageDraw, ImageFont
import os
import math

class ImageGenerator:
    """Step 9: Image Generation Module"""
    
    def __init__(self):
        self.node_width = 120
        self.node_height = 60
        self.font_size = 14
        
    def generate(self, positioned_data, output_dir, metadata=None):
        """
        Generate architecture diagram image with metadata
        metadata: dict with 'topic' and 'design' info
        """
        width = positioned_data['canvas_width']
        height = positioned_data['canvas_height']
        
        # Add space for header if metadata provided
        header_height = 80 if metadata else 0
        total_height = height + header_height
        
        # Create image
        img = Image.new('RGB', (width, total_height), color='#F8F9FA')
        draw = ImageDraw.Draw(img)
        
        # Try to load fonts
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", self.font_size)
            font_small = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 12)
            font_title = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 24)
        except:
            font = ImageFont.load_default()
            font_small = ImageFont.load_default()
            font_title = ImageFont.load_default()
        
        # Draw header if metadata provided
        if metadata:
            # Draw header background
            draw.rectangle([0, 0, width, header_height], fill='#2C3E50')
            
            # Draw title
            topic = metadata.get('topic', 'System').title()
            design = metadata.get('design', 'HLD')
            title_text = f"{topic} - {design} Architecture"
            
            bbox = draw.textbbox((0, 0), title_text, font=font_title)
            title_width = bbox[2] - bbox[0]
            draw.text(((width - title_width) // 2, 20), title_text, fill='#ECF0F1', font=font_title)
            
            # Draw subtitle
            subtitle = "Generated by System Design Visualizer"
            bbox_sub = draw.textbbox((0, 0), subtitle, font=font_small)
            sub_width = bbox_sub[2] - bbox_sub[0]
            draw.text(((width - sub_width) // 2, 50), subtitle, fill='#95A5A6', font=font_small)
        
        positions = positioned_data['positions']
        components = positioned_data['components']
        relationships = positioned_data['relationships']
        
        # Adjust positions if we have a header
        if header_height:
            adjusted_positions = {name: (x, y + header_height) for name, (x, y) in positions.items()}
        else:
            adjusted_positions = positions
        
        # Draw relationships first (behind components)
        for rel in relationships:
            if rel['from'] in adjusted_positions and rel['to'] in adjusted_positions:
                self._draw_arrow(
                    draw,
                    adjusted_positions[rel['from']],
                    adjusted_positions[rel['to']],
                    rel.get('arrow_style', 'solid'),
                    font_small,
                    rel.get('type', '')
                )
        
        # Draw components
        for comp in components:
            if comp['name'] in adjusted_positions:
                self._draw_component(
                    draw,
                    adjusted_positions[comp['name']],
                    comp['name'],
                    comp['shape'],
                    comp['color'],
                    font
                )
        
        # Save image
        filename = 'architecture.png'
        filepath = os.path.join(output_dir, filename)
        img.save(filepath, 'PNG')
        
        return filepath
    
    def _draw_component(self, draw, position, name, shape, color, font):
        """
        Draw a component shape
        """
        x, y = position
        w = self.node_width
        h = self.node_height
        
        # Draw shape
        if shape == 'rectangle':
            self._draw_rectangle(draw, x, y, w, h, color)
        elif shape == 'ellipse':
            self._draw_ellipse(draw, x, y, w, h, color)
        elif shape == 'cylinder':
            self._draw_cylinder(draw, x, y, w, h, color)
        elif shape == 'diamond':
            self._draw_diamond(draw, x, y, w, h, color)
        elif shape == 'hexagon':
            self._draw_hexagon(draw, x, y, w, h, color)
        elif shape == 'parallelogram':
            self._draw_parallelogram(draw, x, y, w, h, color)
        elif shape == 'cloud':
            self._draw_cloud(draw, x, y, w, h, color)
        else:
            self._draw_rectangle(draw, x, y, w, h, color)
        
        # Draw text
        self._draw_text(draw, x, y, w, h, name, font)
    
    def _draw_rectangle(self, draw, x, y, w, h, color):
        x1, y1 = x - w//2, y - h//2
        x2, y2 = x + w//2, y + h//2
        draw.rectangle([x1, y1, x2, y2], fill=color, outline='#2C3E50', width=2)
    
    def _draw_ellipse(self, draw, x, y, w, h, color):
        x1, y1 = x - w//2, y - h//2
        x2, y2 = x + w//2, y + h//2
        draw.ellipse([x1, y1, x2, y2], fill=color, outline='#2C3E50', width=2)
    
    def _draw_cylinder(self, draw, x, y, w, h, color):
        # Body
        x1, y1 = x - w//2, y - h//2 + 10
        x2, y2 = x + w//2, y + h//2
        draw.rectangle([x1, y1, x2, y2], fill=color, outline='#2C3E50', width=2)
        
        # Top ellipse
        draw.ellipse([x1, y - h//2, x2, y - h//2 + 20], fill=color, outline='#2C3E50', width=2)
        
        # Bottom arc
        draw.arc([x1, y2 - 20, x2, y2], start=0, end=180, fill='#2C3E50', width=2)
    
    def _draw_diamond(self, draw, x, y, w, h, color):
        points = [
            (x, y - h//2),        # Top
            (x + w//2, y),        # Right
            (x, y + h//2),        # Bottom
            (x - w//2, y)         # Left
        ]
        draw.polygon(points, fill=color, outline='#2C3E50')
    
    def _draw_hexagon(self, draw, x, y, w, h, color):
        offset = w // 4
        points = [
            (x - w//2 + offset, y - h//2),
            (x + w//2 - offset, y - h//2),
            (x + w//2, y),
            (x + w//2 - offset, y + h//2),
            (x - w//2 + offset, y + h//2),
            (x - w//2, y)
        ]
        draw.polygon(points, fill=color, outline='#2C3E50')
    
    def _draw_parallelogram(self, draw, x, y, w, h, color):
        offset = w // 5
        points = [
            (x - w//2 + offset, y - h//2),
            (x + w//2 + offset, y - h//2),
            (x + w//2 - offset, y + h//2),
            (x - w//2 - offset, y + h//2)
        ]
        draw.polygon(points, fill=color, outline='#2C3E50')
    
    def _draw_cloud(self, draw, x, y, w, h, color):
        # Simple cloud using circles
        r = h // 3
        draw.ellipse([x - w//3, y - r, x + w//3, y + r], fill=color, outline='#2C3E50')
        draw.ellipse([x - w//2, y - r//2, x, y + r//2], fill=color, outline='#2C3E50')
        draw.ellipse([x, y - r//2, x + w//2, y + r//2], fill=color, outline='#2C3E50')
    
    def _draw_text(self, draw, x, y, w, h, text, font):
        # Word wrap text
        words = text.split()
        lines = []
        current_line = []
        
        for word in words:
            test_line = ' '.join(current_line + [word])
            bbox = draw.textbbox((0, 0), test_line, font=font)
            text_width = bbox[2] - bbox[0]
            
            if text_width <= w - 10:
                current_line.append(word)
            else:
                if current_line:
                    lines.append(' '.join(current_line))
                current_line = [word]
        
        if current_line:
            lines.append(' '.join(current_line))
        
        # Draw lines
        line_height = 16
        total_height = len(lines) * line_height
        start_y = y - total_height // 2
        
        for i, line in enumerate(lines):
            bbox = draw.textbbox((0, 0), line, font=font)
            text_width = bbox[2] - bbox[0]
            text_x = x - text_width // 2
            text_y = start_y + i * line_height
            
            draw.text((text_x, text_y), line, fill='white', font=font)
    
    def _draw_arrow(self, draw, from_pos, to_pos, style, font, label):
        """
        Draw arrow between components
        """
        x1, y1 = from_pos
        x2, y2 = to_pos
        
        # Calculate arrow endpoint (edge of target component)
        dx = x2 - x1
        dy = y2 - y1
        dist = math.sqrt(dx*dx + dy*dy)
        
        if dist < 1:
            return
        
        # Shorten arrow to component edge
        edge_offset = 65
        ratio = (dist - edge_offset) / dist
        end_x = x1 + dx * ratio
        end_y = y1 + dy * ratio
        
        # Shorten from start too
        start_ratio = edge_offset / dist
        start_x = x1 + dx * start_ratio
        start_y = y1 + dy * start_ratio
        
        # Draw line
        if style == 'dashed':
            self._draw_dashed_line(draw, start_x, start_y, end_x, end_y)
        else:
            draw.line([start_x, start_y, end_x, end_y], fill='#34495E', width=2)
        
        # Draw arrowhead
        self._draw_arrowhead(draw, start_x, start_y, end_x, end_y)
        
        # Draw label
        if label:
            mid_x = (start_x + end_x) / 2
            mid_y = (start_y + end_y) / 2
            bbox = draw.textbbox((0, 0), label, font=font)
            text_width = bbox[2] - bbox[0]
            draw.text((mid_x - text_width//2, mid_y - 10), label, fill='#7F8C8D', font=font)
    
    def _draw_dashed_line(self, draw, x1, y1, x2, y2, dash_length=10):
        """Draw dashed line"""
        dx = x2 - x1
        dy = y2 - y1
        dist = math.sqrt(dx*dx + dy*dy)
        
        if dist < 1:
            return
        
        num_dashes = int(dist / dash_length)
        for i in range(0, num_dashes, 2):
            t1 = i / num_dashes
            t2 = min((i + 1) / num_dashes, 1.0)
            
            sx = x1 + dx * t1
            sy = y1 + dy * t1
            ex = x1 + dx * t2
            ey = y1 + dy * t2
            
            draw.line([sx, sy, ex, ey], fill='#34495E', width=2)
    
    def _draw_arrowhead(self, draw, x1, y1, x2, y2):
        """Draw arrowhead at end of line"""
        dx = x2 - x1
        dy = y2 - y1
        dist = math.sqrt(dx*dx + dy*dy)
        
        if dist < 1:
            return
        
        # Normalize
        dx /= dist
        dy /= dist
        
        # Arrowhead points
        arrow_length = 15
        arrow_width = 8
        
        # Perpendicular vector
        px = -dy
        py = dx
        
        p1 = (x2, y2)
        p2 = (x2 - arrow_length * dx + arrow_width * px, 
              y2 - arrow_length * dy + arrow_width * py)
        p3 = (x2 - arrow_length * dx - arrow_width * px, 
              y2 - arrow_length * dy - arrow_width * py)
        
        draw.polygon([p1, p2, p3], fill='#34495E')
